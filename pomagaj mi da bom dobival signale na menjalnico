import ccxt
import re
import time
import imaplib
import email
import csv
import os
import json
import threading
import matplotlib.pyplot as plt
from tkinter import *
from tkinter import ttk
import logging
import sys

__all__ = ['exchange_instances', 'check_account_balance']

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(filename='C:\\Python\\trading_bot\\logs\\trading_bot.log', mode='w'),
        logging.StreamHandler(sys.stdout)
    ]
)


with open('C:\\Python\\trading_bot\\api_keys.json') as f:
    api_key_data_list = json.load(f)
with open('C:\\Python\\trading_bot\\email_credentials.json') as f:
    email_credentials = json.load(f)
with open('C:\\Python\\trading_bot\\config.json') as f:
    config = json.load(f)

timeframe = config['timeframe']
limit = config['limit']
percentage = config['percentage']
leverage = config['leverage']

def sync_exchange_time(exchange):
    exchange.load_time_difference()

exchange_instances = [getattr(ccxt, api_key_data['exchange_id'])({
    'apiKey': api_key_data['api_key'],
    'secret': api_key_data['api_secret'],
    'timeout': 30000,
    'enableRateLimit': True,
    'options': {'recvWindow': 60000},
}) for api_key_data in api_key_data_list]

# Sync exchange time
for exchange in exchange_instances:
    sync_exchange_time(exchange)


trading_pairs = ['BTC/USDT', 'ETH/USDT']

stop_trading = False

def get_email_body(msg):
    if msg.is_multipart():
        for part in msg.walk():
            if part.get_content_type() == "text/plain":
                return part.get_payload(decode=True).decode()
    else:
        return msg.get_payload(decode=True).decode()

def read_unread_emails(email_address, email_password):
    try:
        mail = imaplib.IMAP4_SSL("imap.gmail.com")
        mail.login(email_address, email_password)
        mail.select("inbox")
        status, email_ids = mail.search(None, "UNSEEN")
        email_ids = email_ids[0].split()

        unread_emails = []

        for msg_num in email_ids:
            status, msg_data = mail.fetch(msg_num, "(RFC822)")
            raw_email = msg_data[0][1]
            msg = email.message_from_bytes(raw_email)

            msg_subject = msg["Subject"]
            msg_content = get_email_body(msg)

            try:
                signal_data = json.loads(msg_content)

                symbol = signal_data["symbol"]
                side = signal_data["side"]
                stop_loss_percent = signal_data["stop_loss_percent"]
                take_profit_percent = signal_data["take_profit_percent"]

                # Pridobite stanje računa
                account_balance = get_account_balance()

                # Izračunaj količino za naročilo (10% od glavnice)
                quantity = account_balance * 0.1

                # Izvedi naročilo na Binance
                binance_order = create_binance_order(symbol, side, quantity, take_profit_percent, stop_loss_percent)
                print("Izvedeno naročilo na Binance:", binance_order)

                # Izvedi naročilo na Bybit
                bybit_order = create_bybit_order(symbol, side, quantity, take_profit_percent, stop_loss_percent)
                print("Izvedeno naročilo na Bybit:", bybit_order)

            except Exception as e:
                logging.error("Error: %s", e)

            mail.store(msg_num, "+FLAGS", "\\Seen")

    except Exception as e:
        logging.error("Error: %s", e)

    return unread_emails

                 
        return alerts
    except Exception as e:
        logging.error(f"Error: {e}")
        return []
    finally:
        client.logout()


def check_tradingview_alerts():
    email_address = email_credentials['email_address']
    email_password = email_credentials['email_password']

    return read_unread_emails(email_address, email_password)

def log_trade(timestamp, trading_pair, signal, price):
    filename = 'trade_history.csv'
    file_exists = os.path.isfile(filename)

    with open(filename, 'a', newline='') as csvfile:
        headers = ['timestamp', 'trading_pair', 'signal', 'price']
        writer = csv.DictWriter(csvfile, delimiter=',', lineterminator='\n', fieldnames=headers)

        if not file_exists:
            writer.writeheader()

        writer.writerow({'timestamp': timestamp, 'trading_pair': trading_pair, 'signal': signal, 'price': price})

def plot_price_data(trading_pair):
    binance_instance = exchange_instances[0]  # Use the first Binance account for data retrieval
    timeframe = '30m'  # Timeframe for data collection
    limit = 100  # Number of candles in the data

    price_data = binance_instance.fetch_ohlcv(trading_pair, timeframe, limit=limit)
    timestamps, open_prices, high_prices, low_prices, close_prices, volumes = zip(*price_data)

    # Convert timestamps to appropriate format
    timestamps = [time.strftime('%Y-%m-%d %H:%M', time.localtime(ts // 1000)) for ts in timestamps]

    plt.plot(timestamps, close_prices)
    plt.xticks(rotation=45)
    plt.title(f'{trading_pair} Price')
    plt.xlabel('Timestamp')
    plt.ylabel('Price')
    plt.show()

def get_binance_futures_usdt_balance(exchange_instance):
    try:
        balance = exchange_instance.fetch_balance(params={'type': 'future'})
        usdt_balance = balance['USDT']['total']
        return usdt_balance
    except Exception as e:
        logging.error(f"Error fetching Binance Futures balance: {e}")
        return 0

def get_usdt_balance(binance_instance):
    try:
        balance = binance_instance.fetch_balance()
        usdt_balance = balance['free']['USDT']
        return usdt_balance
    except Exception as e:
        logging.error(f"Error fetching balance: {e}")
        return 0

def calculate_order_size(balance, percentage):
    return balance * (percentage / 100)

def main_loop():
    global stop_trading
    email_address = email_credentials['email_address']
    email_password = email_credentials['email_password']
    while not stop_trading:
        try:
            print("Preverjanje e-pošte...")
            logging.info("Preverjanje e-pošte...")
            alerts = read_unread_emails(email_address, email_password)

            logging.info(f"Prejeli ste {len(alerts)} opozoril: {alerts}")
            for signal, trading_pair, side, stop_loss_percent, take_profit_percent in alerts:
                for exchange_instance in exchange_instances:
                    sync_exchange_time(exchange_instance)
                    print(f"Izvajanje naročila na {exchange_instance.name} z naslednjimi parametri:")
                    print("Poselovanje valutni par:", trading_pair)
                    print("Stranski položaj:", side)
                    print("Odstotek za zaustavitev izgube:", stop_loss_percent)
                    print("Odstotek za dobiček:", take_profit_percent)

                for exchange_instance in exchange_instances:
                    for attempt in range(3):
                        try:
                            usdt_balance = get_usdt_balance(exchange_instance)
                            order_size = calculate_order_size(usdt_balance, 10)

                            if signal == 'long':
                                print(f'Kupujem na {exchange_instance.name} za valutni par {trading_pair}')
                                order = exchange_instance.create_market_buy_order(trading_pair, order_size)

                                entry_price = float(order['price'])
                                stop_loss_price = entry_price * (1 - stop_loss_percent)
                                take_profit_price = entry_price * (1 + take_profit_percent)

                                exchange_instance.create_order(trading_pair, 'stop_loss_limit', 'sell', order_size, stop_loss_price, {'stopPrice': stop_loss_price})
                                exchange_instance.create_order(trading_pair, 'limit', 'sell', order_size, take_profit_price)

                            elif signal == 'short':
                                print(f'Prodajam na {exchange_instance.name} za valutni par {trading_pair}')
                                order = exchange_instance.create_market_sell_order(trading_pair, order_size)

                                entry_price = float(order['price'])
                                stop_loss_price = entry_price * (1 + stop_loss_percent)
                                take_profit_price = entry_price * (1 - take_profit_percent)

                                exchange_instance.create_order(trading_pair, 'stop_loss_limit', 'buy', order_size, stop_loss_price, {'stopPrice': stop_loss_price})
                                exchange_instance.create_order(trading_pair, 'limit', 'buy', order_size, take_profit_price)

                            elif signal == 'close':
                                print(f'Zapiram pozicijo na {exchange_instance.name} za valutni par {trading_pair}')
                                order = exchange_instance.create_market_sell_order(trading_pair, order_size, {'reduceOnly': True})

                            timestamp = order['timestamp']
                            price = order['price']
                            log_trade(timestamp, trading_pair, signal, price)
                            break
                        
                        except Exception as e:
                            logging.error(f"Error working with {exchange_instance.name} instance: {e}")
                            if attempt < 2:  # Change 2 to one less than the desired number of retries
                                print("Retrying after 5 seconds...")
                                logging.info("Retrying after 5 seconds...")
                                time.sleep(5)
                            else:
                                print("Max retries reached. Skipping this trade.")
                                logging.warning("Max retries reached. Skipping this trade.")
                                break

            time.sleep(60)
        except Exception as e:
            logging.error(f"Error in main loop: {e}")
            time.sleep(60)

def stop_main_loop():
    global stop_trading
    stop_trading = True

def start_main_loop():
    global stop_trading
    stop_trading = False
    main_thread = threading.Thread(target=main_loop)
    main_thread.start()

def check_account_balance(binance_instance):
    try:
        balance = binance_instance.fetch_balance()
        non_zero_balances = {coin: amount for coin, amount in balance['free'].items() if amount > 0}
        print("Balance:", non_zero_balances)
    except Exception as e:
        print(f"Error fetching balance: {e}")

def create_gui():
    def on_trading_pair_selected(event):
        selected_trading_pair.set(combo_trading_pairs.get())
    
    root = Tk()
    root.title("Trading Bot")

    mainframe = ttk.Frame(root, padding="3 3 12 12")
    mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)

    ttk.Label(mainframe, text="Trading Bot is running").grid(column=1, row=1, sticky=W)

    ttk.Button(mainframe, text="Start", command=start_main_loop).grid(column=3, row=3, sticky=W)
    ttk.Button(mainframe, text="Stop", command=stop_main_loop).grid(column=4, row=3, sticky=W)

    # Create a dropdown menu to select a trading pair
    selected_trading_pair = StringVar()
    combo_trading_pairs = ttk.Combobox(mainframe, textvariable=selected_trading_pair)
    combo_trading_pairs['values'] = trading_pairs
    combo_trading_pairs.grid(column=1, row=3, sticky=W)
    combo_trading_pairs.current(0)  # Set default selected trading pair
    combo_trading_pairs.bind("<<ComboboxSelected>>", on_trading_pair_selected)

    ttk.Button(mainframe, text="Show Graph", command=lambda: plot_price_data(selected_trading_pair.get())).grid(column=5, row=3, sticky=W)

    for child in mainframe.winfo_children():
        child.grid_configure(padx=5, pady=5)

    root.mainloop()
if __name__ == "__main__":
    for i, instance in enumerate(exchange_instances):
        try:
            print(f"Account {i + 1}:")
            futures_usdt_balance = get_binance_futures_usdt_balance(instance)
            print("Futures USDT Balance:", futures_usdt_balance)
        except Exception as e:
            logging.error(f"Error checking account balance: {e}")
    create_gui()
