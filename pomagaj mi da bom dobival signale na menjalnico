import ccxt
import re
import time
import imaplib
import email
import csv
import os
import json
import threading
import matplotlib.pyplot as plt
from tkinter import *
from tkinter import ttk
import logging
import sys

from binance.client import Client as BinanceClient
import bybit


__all__ = ['exchange_instances', 'check_account_balance']

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(filename='C:\\Python\\trading_bot\\logs\\trading_bot.log', mode='w'),
        logging.StreamHandler(sys.stdout)
    ]
)


with open('C:\\Python\\trading_bot\\api_keys.json') as f:
    api_key_data_list = json.load(f)
with open('C:\\Python\\trading_bot\\email_credentials.json') as f:
    email_credentials = json.load(f)
with open('C:\\Python\\trading_bot\\config.json') as f:
    config = json.load(f)

timeframe = config['timeframe']
limit = config['limit']
percentage = config['percentage']
leverage = config['leverage']

def sync_exchange_time(exchange):
    if hasattr(exchange, 'load_time_difference'):
        exchange.load_time_difference()
    else:
        print(f"{type(exchange).__name__} nima funkcije 'load_time_difference'.")


exchange_instances = []

for api_key_data in api_key_data_list:
    if api_key_data["exchange_id"] == "binance":
        binance_instance = BinanceClient(api_key_data["api_key"], api_key_data["api_secret"])
        exchange_instances.append(binance_instance)

    elif api_key_data["exchange_id"] == "bybit":
        bybit_instance = bybit.bybit(test=False, api_key=api_key_data["api_key"], api_secret=api_key_data["api_secret"])
        exchange_instances.append(bybit_instance)

    else:
        instance = getattr(ccxt, api_key_data["exchange_id"])({
            "apiKey": api_key_data["api_key"],
            "secret": api_key_data["api_secret"],
            "timeout": 30000,
            "enableRateLimit": True,
            "options": {"recvWindow": 60000},
        })
        exchange_instances.append(instance)

# Sync exchange time
for exchange in exchange_instances:
    sync_exchange_time(exchange)



trading_pairs = ['BTC/USDT', 'ETH/USDT']

stop_trading = False

def execute_trade(exchange_instance, signal, trading_pair, order_size, stop_loss_percent, take_profit_percent):
    try:
        if signal == 'long':
            print(f'Kupujem na {exchange_instance.name} za valutni par {trading_pair}')
            order = exchange_instance.create_market_buy_order(trading_pair, order_size)

            entry_price = float(order['price'])
            stop_loss_price = entry_price * (1 - stop_loss_percent / 100)
            take_profit_price = entry_price * (1 + take_profit_percent / 100)

            exchange_instance.create_order(trading_pair, 'limit', 'sell', order_size, take_profit_price)
            exchange_instance.create_order(trading_pair, 'stop_loss', 'sell', order_size, stop_loss_price)

        elif signal == 'short':
            print(f'Prodajem na {exchange_instance.name} za valutni par {trading_pair}')
            order = exchange_instance.create_market_sell_order(trading_pair, order_size)

            entry_price = float(order['price'])
            stop_loss_price = entry_price * (1 + stop_loss_percent / 100)
            take_profit_price = entry_price * (1 - take_profit_percent / 100)

            exchange_instance.create_order(trading_pair, 'limit', 'buy', order_size, take_profit_price)
            exchange_instance.create_order(trading_pair, 'stop_loss', 'buy', order_size, stop_loss_price)

        print(f'Naročilo za {signal} izvedeno uspešno!')

    except Exception as e:
        print(f'Napaka pri izvedbi naročila: {e}')
        return None

# Preberi naročila iz seznama opozoril
for signal, trading_pair, side, stop_loss_percent, take_profit_percent in alerts:

    # Uporabi funkcijo execute_trade za izvedbo naročil
 def execute_trade(exchange_instance, signal, trading_pair, order_size, stop_loss_percent, take_profit_percent):   
    for exchange_instance, signal, trading_pair, order_size, stop_loss_percent, take_profit_percent in alerts:
     execute_trade(exchange_instance, signal, trading_pair, order_size, stop_loss_percent, take_profit_percent)


def create_binance_order(exchange, symbol, side, order_type, amount, price=None):
    if order_type == 'market':
        if side == 'buy':
            order = exchange.create_market_buy_order(symbol, amount)
        else:
            order = exchange.create_market_sell_order(symbol, amount)
    else:
        if side == 'buy':
            order = exchange.create_limit_buy_order(symbol, amount, price)
        else:
            order = exchange.create_limit_sell_order(symbol, amount, price)

    return order

def create_bybit_order(exchange, symbol, side, order_type, amount, price=None):
    if order_type == 'market':
        order = exchange.place_active_order(
            side=side.upper(),
            symbol=symbol.replace('/', ''),
            order_type=order_type.upper(),
            qty=amount,
            time_in_force='GTC'
        )
    else:
        order = exchange.place_active_order(
            side=side.upper(),
            symbol=symbol.replace('/', ''),
            order_type=order_type.upper(),
            qty=amount,
            price=price,
            time_in_force='GTC'
        )

    return order

def get_email_body(msg):
    if msg.is_multipart():
        for part in msg.walk():
            if part.get_content_type() == "text/plain":
                return part.get_payload(decode=True).decode()
    else:
        return msg.get_payload(decode=True).decode()

def read_unread_emails(email_address, email_password):
    try:
        client = imaplib.IMAP4_SSL("imap.gmail.com")
        client.login(email_address, email_password)
        client.select("inbox")

        _, messages = client.search(None, 'UNSEEN')
        messages = messages[0].split()

        alerts = []

        for msg_id in messages:
            _, raw_msg = client.fetch(msg_id, "(RFC822)")
            msg = email.message_from_bytes(raw_msg[0][1])

            body = get_email_body(msg)
            print("Received email content:", body)

            symbol_pattern = r'"symbol":\s*"([^"]+)"'
            side_pattern = r'"side":\s*"([^"]+)"'
            stop_loss_percent_pattern = r'"stop_loss_percent":\s*([\d.]+)'
            take_profit_percent_pattern = r'"take_profit_percent":\s*([\d.]+)'

            symbol_match = re.search(symbol_pattern, body)
            side_match = re.search(side_pattern, body)
            stop_loss_percent_match = re.search(stop_loss_percent_pattern, body)
            take_profit_percent_match = re.search(take_profit_percent_pattern, body)

            if symbol_match and side_match and stop_loss_percent_match and take_profit_percent_match:
                trading_pair = symbol_match.group(1)
                side = side_match.group(1).lower()
                stop_loss_percent = float(stop_loss_percent_match.group(1))
                take_profit_percent = float(take_profit_percent_match.group(1))
                alerts.append((trading_pair, side, stop_loss_percent, take_profit_percent))
                
                for alert in alerts:
                 print(alert)
                 alerts.append(body)

        return alerts
    except Exception as e:
        logging.error(f"Error: {e}")
        return []
    finally:
        client.logout()


def check_tradingview_alerts():
    email_address = email_credentials['email_address']
    email_password = email_credentials['email_password']

    return read_unread_emails(email_address, email_password)

def log_trade(timestamp, trading_pair, signal, price):
    filename = 'trade_history.csv'
    file_exists = os.path.isfile(filename)

    with open(filename, 'a', newline='') as csvfile:
        headers = ['timestamp', 'trading_pair', 'signal', 'price']
        writer = csv.DictWriter(csvfile, delimiter=',', lineterminator='\n', fieldnames=headers)

        if not file_exists:
            writer.writeheader()

        writer.writerow({'timestamp': timestamp, 'trading_pair': trading_pair, 'signal': signal, 'price': price})

def plot_price_data(trading_pair):
    binance_instance = exchange_instances[0]  # Use the first Binance account for data retrieval
    timeframe = '30m'  # Timeframe for data collection
    limit = 100  # Number of candles in the data

    price_data = binance_instance.fetch_ohlcv(trading_pair, timeframe, limit=limit)
    timestamps, open_prices, high_prices, low_prices, close_prices, volumes = zip(*price_data)

    # Convert timestamps to appropriate format
    timestamps = [time.strftime('%Y-%m-%d %H:%M', time.localtime(ts // 1000)) for ts in timestamps]

    plt.plot(timestamps, close_prices)
    plt.xticks(rotation=45)
    plt.title(f'{trading_pair} Price')
    plt.xlabel('Timestamp')
    plt.ylabel('Price')
    plt.show()

def get_binance_futures_usdt_balance(exchange_instance):
    try:
        balance = exchange_instance.fetch_balance(params={'type': 'future'})
        usdt_balance = balance['USDT']['total']
        return usdt_balance
    except Exception as e:
        logging.error(f"Error fetching Binance Futures balance: {e}")
        return 0
        
def get_usdt_balance(binance_instance):
    try:
        balance = binance_instance.fetch_balance()
        usdt_balance = balance['free']['USDT']
        return usdt_balance
    except Exception as e:
        logging.error(f"Error fetching balance: {e}")
        return 0
        
def calculate_order_size(balance, percentage):
    return balance * (percentage / 100)

def main_loop():
    global stop_trading
    email_address = email_credentials['email_address']
    email_password = email_credentials['email_password']
    while not stop_trading:
        try:
            print("Preverjanje e-pošte...")
            logging.info("Preverjanje e-pošte...")
            alerts = read_unread_emails(email_address, email_password)

            logging.info(f"Prejeli ste {len(alerts)} opozoril: {alerts}")
            for signal, trading_pair, side, stop_loss_percent, take_profit_percent in alerts:
                for exchange_instance in exchange_instances:
                    sync_exchange_time(exchange_instance)
                    print(f"Izvajanje naročila na {exchange_instance.name} z naslednjimi parametri:")
                    print("Poselovanje valutni par:", trading_pair)
                    print("Stranski položaj:", side)
                    print("Odstotek za zaustavitev izgube:", stop_loss_percent)
                    print("Odstotek za dobiček:", take_profit_percent)

                for exchange_instance in exchange_instances:
                    for attempt in range(3):
                        try:
                            usdt_balance = get_usdt_balance(exchange_instance)
                            order_size = calculate_order_size(usdt_balance, 10)

                            if signal == 'long':
                                print(f'Kupujem na {exchange_instance.name} za valutni par {trading_pair}')
                                order = exchange_instance.create_market_buy_order(trading_pair, order_size)

                                entry_price = float(order['price'])
                                stop_loss_price = entry_price * (1 - stop_loss_percent)
                                take_profit_price = entry_price * (1 + take_profit_percent)

                                exchange_instance.create_order(trading_pair, 'stop_loss_limit', 'sell', order_size, stop_loss_price, {'stopPrice': stop_loss_price})
                                exchange_instance.create_order(trading_pair, 'limit', 'sell', order_size, take_profit_price)

                            elif signal == 'short':
                                print(f'Prodajam na {exchange_instance.name} za valutni par {trading_pair}')
                                order = exchange_instance.create_market_sell_order(trading_pair, order_size)

                                entry_price = float(order['price'])
                                stop_loss_price = entry_price * (1 + stop_loss_percent)
                                take_profit_price = entry_price * (1 - take_profit_percent)

                                exchange_instance.create_order(trading_pair, 'stop_loss_limit', 'buy', order_size, stop_loss_price, {'stopPrice': stop_loss_price})
                                exchange_instance.create_order(trading_pair, 'limit', 'buy', order_size, take_profit_price)

                            elif signal == 'close':
                                print(f'Zapiram pozicijo na {exchange_instance.name} za valutni par {trading_pair}')
                                order = exchange_instance.create_market_sell_order(trading_pair, order_size, {'reduceOnly': True})

                            timestamp = order['timestamp']
                            price = order['price']
                            log_trade(timestamp, trading_pair, signal, price)
                            break
                        
                        except Exception as e:
                            logging.error(f"Error working with {exchange_instance.name} instance: {e}")
                            if attempt < 2:  # Change 2 to one less than the desired number of retries
                                print("Retrying after 5 seconds...")
                                logging.info("Retrying after 5 seconds...")
                                time.sleep(5)
                            else:
                                print("Max retries reached. Skipping this trade.")
                                logging.warning("Max retries reached. Skipping this trade.")
                                break

            time.sleep(60)
        except Exception as e:
            logging.error(f"Error in main loop: {e}")
            time.sleep(60)

def stop_main_loop():
    global stop_trading
    stop_trading = True

def start_main_loop():
    global stop_trading
    stop_trading = False
    main_thread = threading.Thread(target=main_loop)
    main_thread.start()

def check_account_balance(binance_instance):
    try:
        balance = binance_instance.fetch_balance()
        non_zero_balances = {coin: amount for coin, amount in balance['free'].items() if amount > 0}
        print("Balance:", non_zero_balances)
    except Exception as e:
        print(f"Error fetching balance: {e}")

def create_gui():
    def on_trading_pair_selected(event):
        selected_trading_pair.set(combo_trading_pairs.get())
    
    root = Tk()
    root.title("Trading Bot")

    mainframe = ttk.Frame(root, padding="3 3 12 12")
    mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)

    ttk.Label(mainframe, text="Trading Bot is running").grid(column=1, row=1, sticky=W)

    ttk.Button(mainframe, text="Start", command=start_main_loop).grid(column=3, row=3, sticky=W)
    ttk.Button(mainframe, text="Stop", command=stop_main_loop).grid(column=4, row=3, sticky=W)

    # Create a dropdown menu to select a trading pair
    selected_trading_pair = StringVar()
    combo_trading_pairs = ttk.Combobox(mainframe, textvariable=selected_trading_pair)
    combo_trading_pairs['values'] = trading_pairs
    combo_trading_pairs.grid(column=1, row=3, sticky=W)
    combo_trading_pairs.current(0)  # Set default selected trading pair
    combo_trading_pairs.bind("<<ComboboxSelected>>", on_trading_pair_selected)

    ttk.Button(mainframe, text="Show Graph", command=lambda: plot_price_data(selected_trading_pair.get())).grid(column=5, row=3, sticky=W)

    for child in mainframe.winfo_children():
        child.grid_configure(padx=5, pady=5)

    root.mainloop()
if __name__ == "__main__":
    for i, instance in enumerate(exchange_instances):
        try:
            print(f"Account {i + 1}:")
            futures_usdt_balance = get_binance_futures_usdt_balance(instance)
            print("Futures USDT Balance:", futures_usdt_balance)
        except Exception as e:
            logging.error(f"Error checking account balance: {e}")
    create_gui()
